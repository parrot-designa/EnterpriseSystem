package com.enterprisesystem.babysecure.shiro.realm;

import com.enterprisesystem.babysecure.mapper.UserMapper;
import com.enterprisesystem.babysecure.model.entity.UserEntity;
import com.enterprisesystem.babysecure.shiro.config.JwtToken;
import org.apache.shiro.authc.*;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.authz.SimpleAuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

import javax.annotation.Resource;

/**
 * 用户自定义 Realm
 *
 * 【功能说明】
 * 实现 Shiro 的认证和授权逻辑
 * - 认证：验证用户身份（登录）
 * - 授权：验证用户权限（访问控制）
 *
 * 【JWT 集成】
 * 支持 JWT Token 认证，从 Token 中解析用户信息
 *
 * 【Bean 注册】
 * 注意：此类不使用 @Component 注解，而是通过 ShiroConfig 中的 @Bean 方式注册
 * 这样可以避免 Bean 重复定义，并且更符合 Shiro 的配置规范
 *
 * @author Generated by Claude Code
 * @date 2026-01-05
 */
public class UserRealm extends AuthorizingRealm {

    /**
     * 注入 UserMapper，用于查询用户信息
     */
    @Resource
    private UserMapper userMapper;

    /**
     * 构造函数：明确指定此 Realm 只支持 JwtToken
     * 这很重要，因为 Shiro 会根据此方法判断是否使用该 Realm
     */
    public UserRealm() {
        // 设置 CredentialMatcher（可选）
        // 由于我们使用 JWT，不需要传统的密码匹配器
    }

    /**
     * 判断此 Realm 是否支持指定的 Token
     *
     * 【重要】必须重写此方法，否则 Shiro 会使用默认的 UsernamePasswordToken
     * 而不是我们自定义的 JwtToken
     *
     * @param token 传入的认证 Token
     * @return true-支持 JwtToken，false-不支持其他类型 Token
     */
    @Override
    public boolean supports(AuthenticationToken token) {
        return token instanceof JwtToken;
    }

    /**
     * 授权方法：验证用户权限
     *
     * 【调用时机】
     * - 用户访问需要权限的接口时（如 @RequiresPermissions）
     * - 使用 @RequiresRoles 注解时
     * - 在代码中调用 subject.checkRole() 或 subject.checkPermission() 时
     *
     * 【执行流程】
     * 1. 从 PrincipalCollection 中获取用户标识（通常是用户 ID 或账号）
     * 2. 根据用户标识查询用户的角色和权限
     * 3. 返回 AuthorizationInfo 对象，包含用户的角色和权限信息
     *
     * 【当前实现】
     * 简单实现：所有认证通过的用户都给予基本权限
     * 实际项目：需要查询数据库，加载用户的角色和权限
     *
     * @param principals 用户身份信息集合（包含认证时存入的信息）
     * @return 授权信息，包含角色和权限
     */
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        // ==================== 1. 获取用户标识 ====================
        // principals.getPrimaryPrincipal() 返回认证时存入的第一个对象
        // 在我们的登录逻辑中，存入的是用户账号（String）
        String account = (String) principals.getPrimaryPrincipal();

        // ==================== 2. 创建授权信息对象 ====================
        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();

        // ==================== 3. 查询并设置角色和权限 ====================
        // 【实际项目中的实现】
        // - 查询数据库获取用户的角色列表
        // - 查询数据库获取用户的权限列表
        // List<String> roles = userMapper.selectRolesByAccount(account);
        // List<String> permissions = userMapper.selectPermissionsByAccount(account);
        // authorizationInfo.addRoles(roles);
        // authorizationInfo.addStringPermissions(permissions);

        // 【当前简单实现】
        // 给所有登录用户添加一个默认角色（可根据业务需求调整）
        authorizationInfo.addRole("user");

        // 示例：如果是管理员账号，添加管理员角色和权限
        if ("admin".equals(account)) {
            authorizationInfo.addRole("admin");
            authorizationInfo.addStringPermission("user:*");  // 用户模块的所有权限
        }

        // ==================== 4. 返回授权信息 ====================
        return authorizationInfo;
    }

    /**
     * 认证方法：验证用户身份
     *
     * 【调用时机】
     * - 用户登录时（Subject.login()）
     * - 每次请求时（如果使用 JWT 过滤器，会验证 Token 有效性）
     *
     * 【执行流程】
     * 1. 从 Token 中获取用户身份信息（如账号、Token 字符串）
     * 2. 查询数据库，验证用户是否存在
     * 3. 验证 Token 是否有效（JWT 签名、过期时间等）
     * 4. 验证用户状态（是否被锁定、禁用等）
     * 5. 返回 AuthenticationInfo，表示认证成功
     * 6. 如果认证失败，抛出相应的异常
     *
     * 【异常类型】
     * - UnknownAccountException：账号不存在
     * - IncorrectCredentialsException：凭证错误（密码错误、Token 无效）
     * - LockedAccountException：账号被锁定
     * - DisabledAccountException：账号被禁用
     * - ExcessiveAttemptsException：登录失败次数过多
     *
     * @param token 认证 Token（JwtToken）
     * @return 认证信息，包含用户身份和凭证
     * @throws AuthenticationException 认证失败时抛出
     */
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        // ==================== 1. 获取 Token 中的用户信息 ====================
        // 强制转换为 JwtToken
        JwtToken jwtToken = (JwtToken) token;

        // 从 Token 中获取用户账号（在 JwtFilter 中已解析并存入）
        String account = (String) jwtToken.getPrincipal();

        // ==================== 2. 查询用户信息 ====================
        // 根据账号查询用户
        UserEntity user = userMapper.selectByAccount(account);

        // ==================== 3. 验证用户是否存在 ====================
        if (user == null) {
            // 账号不存在
            throw new UnknownAccountException("账号【" + account + "】不存在");
        }

        // ==================== 4. 验证用户状态 ====================
        // 检查用户状态（假设 1-启用，0-禁用）
        if (user.getCStatus() != null && user.getCStatus() != 1) {
            // 账号已被禁用
            throw new DisabledAccountException("账号【" + account + "】已被禁用");
        }

        // 检查账号是否过期（如果有设置有效期）
        // if (user.getAccountValidDate() != null && user.getAccountValidDate().before(new Date())) {
        //     throw new ExpiredCredentialsException("账号【" + account + "】已过期");
        // }

        // 检查登录失败次数（防止暴力破解）
        if (user.getLoginFailCount() != null && user.getLoginFailCount() >= 5) {
            throw new LockedAccountException("账号【" + account + "】已被锁定，登录失败次数过多");
        }

        // ==================== 5. 验证 Token 有效性 ====================
        // JWT 的签名验证在 JwtFilter 中已完成
        // 这里只需要验证用户状态即可

        // ==================== 6. 返回认证信息 ====================
        // 参数说明：
        // - principals：用户身份信息（通常是账号或用户对象），存入 PrincipalCollection
        // - credentials：凭证（密码或 Token），用于比对
        // - realmName：Realm 名称
        //
        // 注意：由于我们使用 JWT，不需要密码比对，所以 credentials 可以传 Token 字符串或 null
        return new SimpleAuthenticationInfo(
                account,                          // 身份信息：用户账号
                jwtToken.getCredentials(),        // 凭证：JWT Token 字符串
                getName()                         // Realm 名称
        );
    }
}
