package com.enterprisesystem.babysecure.shiro.filter;

import com.enterprisesystem.babycommon.exception.SystemRuntimeException;
import com.enterprisesystem.babysecure.shiro.config.JwtToken;
import io.jsonwebtoken.*;
import org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * JWT 过滤器
 *
 * 【功能说明】
 * 拦截 HTTP 请求，从请求头中提取 JWT Token 并进行验证
 * 验证通过后，将 Token 中的用户信息设置到 Shiro 上下文中
 *
 * 【执行流程】
 * 1. preHandle：请求预处理
 *    - 检查请求头是否包含 JWT Token
 *    - 验证 Token 的有效性和签名
 *    - 调用 Shiro 的 login() 方法，将 Token 提交给 Realm 认证
 * 2. isAccessAllowed：判断是否允许访问
 * 3. onAccessDenied：访问拒绝时的处理
 *
 * 【JWT Token 格式】
 * Authorization: BABY_SSO_JWT <jwt_token>
 *
 * @author Generated by Claude Code
 * @date 2026-01-05
 */
@Component
public class JwtFilter extends BasicHttpAuthenticationFilter {

    /**
     * JWT Token 前缀（在请求头中的标识）
     */
    private static final String AUTH_PREFIX = "BABY_SSO_JWT";

    /**
     * JWT 密钥（与 JwtUtil 中保持一致）
     */
    private static final String JWT_SECRET = "BABY_SSO_JWT_PWD";

    /**
     * 请求预处理：在每个请求被处理之前调用
     *
     * 【执行顺序】
     * 1. 检查请求头中的 Token
     * 2. 验证 Token 有效性
     * 3. 提交 Token 给 Shiro Realm 进行认证
     *
     * 【返回值】
     * - true：继续处理请求
     * - false：拒绝请求，直接返回响应
     *
     * @param request  Servlet 请求
     * @param response Servlet 响应
     * @return true-允许访问，false-拒绝访问
     * @throws Exception 处理过程中的异常
     */
    @Override
    protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception {
        // ==================== 1. 强制类型转换 ====================
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        HttpServletResponse httpServletResponse = (HttpServletResponse) response;

        // ==================== 2. 跨域处理 ====================
        // 如果是 OPTIONS 请求（预检请求），直接返回 true
        if ("OPTIONS".equals(httpServletRequest.getMethod())) {
            httpServletResponse.setStatus(HttpServletResponse.SC_OK);
            return false;
        }

        // ==================== 3. 提取 JWT Token ====================
        // 从请求头获取 Authorization
        String auth = httpServletRequest.getHeader("Authorization");

        // ==================== 4. 验证 Token 格式 ====================
        if (StringUtils.hasText(auth) && auth.startsWith(AUTH_PREFIX)) {
            // 提取 JWT Token（去掉前缀）
            String jwtToken = auth.substring(AUTH_PREFIX.length()).trim();

            try {
                // ==================== 5. 验证 JWT Token 签名和有效性 ====================
                // 解析 JWT Token，验证签名和过期时间
                Claims claims = validateJwtToken(jwtToken);

                // ==================== 6. 提取用户信息 ====================
                // 从 Token 中提取用户账号（在登录时存入的）
                String account = (String) claims.get("account");

                if (account != null) {
                    // ==================== 7. 创建 JwtToken 对象 ====================
                    JwtToken token = new JwtToken(jwtToken, account);

                    // ==================== 8. 提交给 Shiro Realm 进行认证 ====================
                    // 这会触发 UserRealm.doGetAuthenticationInfo() 方法
                    getSubject(request, response).login(token);

                    // 认证成功，继续处理请求
                    return true;
                } else {
                    // Token 中没有用户信息
                    responseError(httpServletResponse, 401, "Token 中缺少用户信息");
                    return false;
                }
            } catch (ExpiredJwtException e) {
                // Token 已过期
                responseError(httpServletResponse, 401, "Token 已过期，请重新登录");
                return false;
            } catch (SignatureException e) {
                // Token 签名无效
                responseError(httpServletResponse, 401, "Token 签名无效");
                return false;
            } catch (MalformedJwtException e) {
                // Token 格式错误
                responseError(httpServletResponse, 401, "Token 格式错误");
                return false;
            } catch (Exception e) {
                // 其他异常
                responseError(httpServletResponse, 401, "Token 验证失败：" + e.getMessage());
                return false;
            }
        }

        // ==================== 9. 没有 Token 或格式错误 ====================
        // 根据业务需求，可以：
        // - 方案 1：要求所有请求都必须携带 Token（返回 401）
        // - 方案 2：允许匿名访问某些路径（如登录接口、注册接口）
        //
        // 这里采用方案 2：允许匿名访问（具体哪些路径允许匿名，在 ShiroConfig 中配置）
        return true;
    }

    /**
     * 验证 JWT Token 的有效性
     *
     * 【验证内容】
     * 1. 签名验证：使用密钥验证签名是否有效
     * 2. 过期时间：检查 Token 是否已过期
     * 3. 格式验证：检查 Token 格式是否正确
     *
     * @param jwtToken JWT Token 字符串
     * @return 解析后的 Claims 对象（包含 Token 中的数据）
     * @throws ExpiredJwtException Token 已过期
     * @throws SignatureException 签名无效
     * @throws MalformedJwtException Token 格式错误
     */
    private Claims validateJwtToken(String jwtToken) throws ExpiredJwtException, SignatureException, MalformedJwtException {
        // 使用 Jwts 解析器验证 Token
        // setSigningKey()：设置签名密钥（与生成 Token 时的密钥一致）
        // parseClaimsJws()：解析 JWT Token，同时验证签名和过期时间
        return Jwts.parserBuilder()
                .setSigningKey(JWT_SECRET.getBytes())
                .build()
                .parseClaimsJws(jwtToken)
                .getBody();
    }

    /**
     * 判断是否允许访问（已登录的用户）
     *
     * 【说明】
     * 此方法在 isAccessAllowed() 中被调用
     * 如果返回 true，表示用户已登录，允许访问
     * 如果返回 false，表示用户未登录，进入 onAccessDenied() 方法
     *
     * @param request     Servlet 请求
     * @param response    Servlet 响应
     * @param mappedValue 映射值（配置中的参数）
     * @return true-已登录，false-未登录
     */
    @Override
    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {
        // 检查用户是否已登录
        // getSubject(request, response).isAuthenticated() 返回 true 表示已登录
        return getSubject(request, response).isAuthenticated();
    }

    /**
     * 访问拒绝时的处理（用户未登录）
     *
     * 【调用时机】
     * 当 isAccessAllowed() 返回 false 且请求要求登录时
     *
     * @param request  Servlet 请求
     * @param response Servlet 响应
     * @return false-表示已处理，不再继续执行
     */
    @Override
    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException {
        // 用户未登录，返回 401 未授权
        responseError((HttpServletResponse) response, 401, "未登录或 Token 无效，请先登录");
        return false;
    }

    /**
     * 发送错误响应
     *
     * @param response   Servlet 响应
     * @param status     HTTP 状态码
     * @param message    错误消息
     */
    private void responseError(HttpServletResponse response, int status, String message) throws IOException {
        // 设置响应状态码
        response.setStatus(status);

        // 设置响应内容类型为 JSON
        response.setContentType("application/json;charset=UTF-8");

        // 设置跨域响应头（根据需要调整）
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
        response.setHeader("Access-Control-Allow-Headers", "Authorization, Content-Type");

        // 构造错误响应 JSON
        String jsonResponse = String.format("{\"code\":%d,\"message\":\"%s\",\"data\":null,\"timestamp\":%d}",
                status, message, System.currentTimeMillis());

        // 写入响应
        response.getWriter().write(jsonResponse);
    }
}
