package com.enterprisesystem.babysecure.config;

import com.enterprisesystem.babysecure.shiro.filter.JwtFilter;
import com.enterprisesystem.babysecure.shiro.realm.UserRealm;
import org.apache.shiro.authc.credential.CredentialsMatcher;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.mgt.DefaultSessionStorageEvaluator;
import org.apache.shiro.mgt.DefaultSubjectDAO;
import org.apache.shiro.realm.Realm;
import org.apache.shiro.spring.LifecycleBeanPostProcessor;
import org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.DependsOn;

import javax.servlet.Filter;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Shiro 配置类
 *
 * 【功能说明】
 * 配置 Shiro 的核心组件，集成 JWT Token 认证
 *
 * 【核心组件】
 * 1. Realm：UserRealm - 认证和授权的核心
 * 2. SecurityManager：安全管理器 - 协调所有安全操作
 * 3. ShiroFilter：过滤器 - 拦截请求，进行权限控制
 * 4. JwtFilter：JWT 过滤器 - 验证 JWT Token
 *
 * 【配置说明】
 * - 禁用 Session：使用 JWT 无状态认证
 * - 配置匿名访问路径：登录、注册等接口不需要 Token
 * - 配置受保护路径：其他接口需要携带 JWT Token
 *
 * @author Generated by Claude Code
 * @date 2026-01-05
 */
@Configuration
public class ShiroConfig {

    /**
     * 配置 UserRealm
     *
     * 【说明】
     * UserRealm 是自定义的 Realm，实现认证和授权逻辑
     * 使用 @Component 注解，Spring 会自动扫描并注册到容器
     *
     * 这里使用 @Bean("userRealm") 确保在配置中可以引用
     *
     * @return UserRealm 实例
     */
    @Bean("userRealm")
    public UserRealm userRealm() {
        UserRealm userRealm = new UserRealm();

        // ==================== 设置凭证匹配器（可选）====================
        // 由于我们使用 JWT，不需要传统的密码匹配器
        // 如果需要支持用户名密码登录，可以配置 HashedCredentialsMatcher
        // userRealm.setCredentialsMatcher(hashedCredentialsMatcher());

        return userRealm;
    }

    /**
     * 配置安全管理器
     *
     * 【职责】
     * - 管理 Realm（可以配置多个 Realm）
     * - 管理 Subject（用户主体）
     * - 协调认证、授权、会话等操作
     *
     * 【重要配置】
     * - 禁用 Session：由于使用 JWT 无状态认证，不需要 Session
     * - 设置自定义 Realm
     *
     * @return DefaultWebSecurityManager 实例
     */
    @Bean("securityManager")
    public DefaultWebSecurityManager securityManager() {
        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();

        // ==================== 1. 设置 Realm ====================
        // 设置自定义的 UserRealm
        securityManager.setRealm(userRealm());

        // ==================== 2. 禁用 Session ====================
        // 由于使用 JWT 无状态认证，不需要 Shiro 的 Session 管理
        DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO();
        DefaultSessionStorageEvaluator sessionStorageEvaluator = new DefaultSessionStorageEvaluator();
        sessionStorageEvaluator.setSessionStorageEnabled(false);  // 禁用 Session
        subjectDAO.setSessionStorageEvaluator(sessionStorageEvaluator);
        securityManager.setSubjectDAO(subjectDAO);

        return securityManager;
    }

    /**
     * 配置 Shiro 过滤器工厂
     *
     * 【职责】
     * - 拦截所有 HTTP 请求
     * - 根据配置的规则，决定哪些路径需要认证，哪些可以匿名访问
     * - 将请求交给对应的 Filter 处理
     *
     * 【过滤器链规则】
     * Map<String, String> filterChainDefinitionMap
     * - Key：URL 路径（支持通配符，如 /api/**）
     * - Value：过滤器名称或过滤器链
     *
     * 【常用过滤器】
     * - anon：匿名访问，不需要认证
     * - authc：需要认证（FormAuthenticationFilter）
     * - user：需要登录或记住我
     * - logout：登出（LogoutFilter）
     * - roles：需要指定角色
     * - perms：需要指定权限
     * - jwt：自定义的 JWT 过滤器
     *
     * 【配置顺序】
     * 从上到下匹配，一旦匹配成功，不再继续匹配
     * 因此，具体的路径要放在前面，通配符路径放在最后
     *
     * 【Bean 名称】
     * 必须命名为 "shiroFilterFactoryBean"，因为 Shiro 的自动配置类会根据这个名称查找 Bean
     *
     * @return ShiroFilterFactoryBean 实例
     */
    @Bean("shiroFilterFactoryBean")
    public ShiroFilterFactoryBean shiroFilterFactoryBean() {
        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();

        // ==================== 1. 设置安全管理器 ====================
        shiroFilter.setSecurityManager(securityManager());

        // ==================== 2. 配置自定义过滤器 ====================
        Map<String, Filter> filters = new HashMap<>();
        filters.put("jwt", new JwtFilter());  // 注册自定义的 JWT 过滤器
        shiroFilter.setFilters(filters);

        // ==================== 3. 配置过滤器链规则 ====================
        Map<String, String> filterChainDefinitionMap = new LinkedHashMap<>();

        // ==================== 3.1 匿名访问路径（不需要 Token）====================
        // 登录接口（重要：登录接口不能拦截，否则无法登录）
        // 根据实际 LoginController 的路径配置
        filterChainDefinitionMap.put("/api/v1/login/**", "anon");
        filterChainDefinitionMap.put("/login/**", "anon");

        // 注册接口（如果有的话）
        filterChainDefinitionMap.put("/api/v1/auth/register", "anon");
        filterChainDefinitionMap.put("/auth/register", "anon");

        // 健康检查接口（用于监控系统）
        filterChainDefinitionMap.put("/health", "anon");
        filterChainDefinitionMap.put("/actuator/**", "anon");

        // Swagger UI 接口（开发环境）
        filterChainDefinitionMap.put("/swagger-ui/**", "anon");
        filterChainDefinitionMap.put("/swagger-resources/**", "anon");
        filterChainDefinitionMap.put("/v3/api-docs/**", "anon");
        filterChainDefinitionMap.put("/webjars/**", "anon");

        // 静态资源
        filterChainDefinitionMap.put("/static/**", "anon");
        filterChainDefinitionMap.put("/css/**", "anon");
        filterChainDefinitionMap.put("/js/**", "anon");
        filterChainDefinitionMap.put("/images/**", "anon");
        filterChainDefinitionMap.put("/favicon.ico", "anon");

        // ==================== 3.2 受保护的路径（需要 JWT Token）====================
        // 使用自定义的 jwt 过滤器
        // filterChainDefinitionMap.put("/api/**", "jwt");  // 所有 API 接口都需要 JWT Token
        // filterChainDefinitionMap.put("/**", "jwt");       // 所有路径都需要 JWT Token

        // ==================== 3.3 默认规则 ====================
        // 其他所有路径都需要认证
        // 注意：这个规则要放在最后，因为它会匹配所有路径
        filterChainDefinitionMap.put("/**", "anon");  // 临时设置为 anon，方便调试
        // 生产环境改为：filterChainDefinitionMap.put("/**", "jwt");

        shiroFilter.setFilterChainDefinitionMap(filterChainDefinitionMap);

        // ==================== 4. 配置登录相关（可选）====================
        // 如果使用表单登录，可以配置登录页面和登录成功跳转页面
        // 由于我们使用 JWT + AJAX，这些配置可以不设置
        // shiroFilter.setLoginUrl("/api/v1/auth/login");  // 登录页面（未认证时跳转）
        // shiroFilter.setSuccessUrl("/index");            // 登录成功跳转页面
        // shiroFilter.setUnauthorizedUrl("/unauthorized"); // 未授权页面

        return shiroFilter;
    }

    /**
     * 配置凭证匹配器（可选）
     *
     * 【说明】
     * 如果使用传统的用户名密码登录，需要配置密码匹配器
     * 用于验证用户输入的密码与数据库中的加密密码是否匹配
     *
     * 由于我们使用 JWT 认证，这个方法暂时不需要
     * 保留此方法供未来扩展（如支持用户名密码登录 + JWT 双重认证）
     *
     * @return HashedCredentialsMatcher 实例
     */
    @Bean
    public CredentialsMatcher hashedCredentialsMatcher() {
        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher();

        // 设置加密算法（与 UserServiceImpl 中使用的算法一致）
        // UserServiceImpl 使用 SHA-256，所以这里也设置为 SHA-256
        hashedCredentialsMatcher.setHashAlgorithmName("SHA-256");

        // 设置迭代次数（如果使用了多次哈希）
        hashedCredentialsMatcher.setHashIterations(1);

        // 是否存储为十六进制（true-十六进制，false-Base64）
        // UserServiceImpl 中使用 convertByteToHexString，所以是十六进制
        hashedCredentialsMatcher.setStoredCredentialsHexEncoded(true);

        return hashedCredentialsMatcher;
    }

    /**
     * 配置 LifecycleBeanPostProcessor
     *
     * 【说明】
     - 管理 Shiro Bean 的生命周期（如初始化、销毁）
     * 自动调用 Shiro 组件的 init() 和 destroy() 方法
     *
     * @return LifecycleBeanPostProcessor 实例
     */
    @Bean
    public LifecycleBeanPostProcessor lifecycleBeanPostProcessor() {
        return new LifecycleBeanPostProcessor();
    }

    /**
     * 配置 DefaultAdvisorAutoProxyCreator
     *
     * 【说明】
     * 启用 Shiro 的注解支持（如 @RequiresPermissions, @RequiresRoles）
     * 自动为使用了 Shiro 注解的 Bean 创建代理
     *
     * 【依赖关系】
     * 必须在 LifecycleBeanPostProcessor 之后创建，所以使用 @DependsOn
     *
     * @return DefaultAdvisorAutoProxyCreator 实例
     */
    @Bean
    @DependsOn("lifecycleBeanPostProcessor")
    public DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator() {
        DefaultAdvisorAutoProxyCreator advisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();
        advisorAutoProxyCreator.setProxyTargetClass(true);  // 使用 CGLIB 代理
        return advisorAutoProxyCreator;
    }

    /**
     * 配置 AuthorizationAttributeSourceAdvisor
     *
     * 【说明】
     * 启用 Shiro 注解支持
     * 配合 DefaultAdvisorAutoProxyCreator 使用
     * 使得 @RequiresPermissions、@RequiresRoles 等注解生效
     *
     * @return AuthorizationAttributeSourceAdvisor 实例
     */
    @Bean
    public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() {
        AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor();
        advisor.setSecurityManager(securityManager());
        return advisor;
    }
}
